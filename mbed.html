<script type="module">
import { comb, makeLexer } from "./comb.js";

const skip = [ "whitespace", "comment" ];

const rules = {
  "[": "[",
  "]": "]",
  "{": "{",
  "}": "}",
  "(": "(",
  ")": ")",
  ",": ",",
  "|": "|",
  "then": "then",
  ".": ".",
  "if": "if",
  // "elif": "elif",
  "else": "else",
  "for": "for",
  "in": "in",
  "fn": "fn",
  "break": "break",
  "continue": "continue",
  // "do": "do",

  // "enum": "enum",
  // "const": "const",

  "return": "return",
  "type": "type",
  "include": "include",
  // ";": ";",
  "=": "=",
  ":": ":",
  // "?": "?",
  binaryOperator: ['*', '/', '==', '!=', '+', '-', '<', '<=', '>', '>=', '<<', '>>', "|", "&", "%", "+=", "-=", "&&", "||"],
  unaryOperator: ['+', '-', '!'],
  number: /\d+(\.\d+)?/,
  string: /"([^"]*)"/,
  boolean: ["true", "false"],
  // primitive: [
  //   "string", 
  //   "boolean", 
  //   "int8",
  //   "int16",
  //   "int32",
  //   "int64",  
  //   "uint8",
  //   "uint16",
  //   "uint32",
  //   "uint64",
  //   "float8",
  //   "float16",
  //   "float32",
  //   "float64",
  //   "byte",
  //   "char",
  //   "void",
  // ],
  id: /[a-zA-Z_][a-zA-Z0-9_]*/,
  whitespace: /[ \t\r\n]*/,
  comment: /\/\/.*\n/
}


const parse = comb`
  lexer ${ { rules, skip } }

  include = 'include' 'string'

  declare = 'id' ':' typeDefinition? '=' expression
  declare -> ${x => {
    const [ id, colon, typeDefinition, equals, expression ] = x;
    let line = "";

    // check if all caps then make it a constant
    const constant = false;
    if (constant) line += "const";

    // if no type definition then infer
    if (typeDefinition) line += typeDefinition;

    line += id.value;
    line += " = ";
    line += expression;

    return line;
  }}

  assign = 'id' '=' expression

  type = 'type' 'id' '=' typeDefinition

  typeDefinition = typeTerm ('|' typeTerm)*
  typeTerm = arrayType | objectType | ('id' '.' 'id') | 'id' | 'string'

  arrayType = 'id' '[' 'number' ']'

  objectType = '{' (fieldDefinition ',')* fieldDefinition? '}'
  fieldDefinition = 'id' ':' typeDefinition

  function = 'fn' 'id' '(' parameters ')' ':' typeDefinition '{' (statement | returnStatement)* '}'
  parameters = (parameter ',')* parameter?
  parameter = 'id' ':' typeDefinition

  statement = type 
    | function 
    | forStatement
    | ifStatement 
    | expression
    | 'continue'
    | 'break'

  returnStatement = 'return' expression?
  
  ifStatement = 'if' expression '{' statement* '}' ( 'else' 'if' expression '{' statement* '}')* ( 'else' '{' statement* '}')?

  forStatement = 'for' ('id' 'in' expression)? '{' statement* '}'
  forStatement -> ${ x => {
    if (x[1]) {
      // need to get size of array
      // const uuid = `variable_${Date.now()}`;
      // return `for (int ${uuid} = 0; ${uuid} < (${x[1][2]}))`
    } else {
      return `while (true) {\n${x[3].map(x => `  ${x};\n`).join("")}}`
    }

  }}

  call = 'id' '(' (expression ',')* expression? ')'
  call -> ${x => {
    const [id, _0, args, opLastArg] = x;
    return `${id.value}(${args.map(x => x[0]).join(", ")}${opLastArg ? `, ${opLastArg}` : ""})`
  }}

  literal = 'number' | 'string' | 'boolean' | 'id'
  literal -> ${x => {
    if (x.type === "boolean" && x.value === "true") return "1";
    if (x.type === "boolean" && x.value === "false") return "0"; 

    return x.value
  }}

  ternary = 'if' expression 'then' expression 'else' expression
  ternary -> ${x => {
    return `((${x[1]}) ? (${x[3]}) : (${x[5]}))`
  }}

  array = '[' (expression ',')* expression? ']'
  array -> ${x => {
    const [_0, values, opLastValue] = x;
    return `{ ${values.map(x => x[0]).join(", ")}${opLastValue ? `, ${opLastValue}` : ""} }`
  }}

  partialExp = assign 
    | declare 
    | call 
    | literal
    | ternary
    | array
    | 'unaryOperator' expression

  biOp = partialExp 'binaryOperator' expression

  expression = biOp | ('(' expression ')') | partialExp

  include* statement*
`

const example = String.raw`
include "Servo.h"

const SPU = 400
const PIN_SERVO = 3

test = 1

test = ["a", "b", "c"]


type option = "c" | "d"

type optionArr = option[4]

type car = {
  door: number,
  color: string
}

fn add(x: int, y: int): int {
  for {
    if x < 10 { break }
    else { 
      x += 1 
      continue
    }
  }

  return x+y
}

for {
  if x < 10 { break }
  else { 
    x += 1 
    continue
  }
}

for {
  if x < 10 { break }
  else { 
    x += 1 
    continue
  }
}
`

const tokenizer = makeLexer({ rules, skip });

const test = String.raw`
include "servo.h"

SPU :int = 400
PIN_SERVO := 3

test = 1

type arr = orange[3]

type house = {
  door: "number"
}

if x < 89 {

} else {
  65
}

if x < 89 {

} else if true {
  65
}

if 78 then 67 else 56

for x in 32 {

}

5 - 9 + 7

fn add(x: number, y: number): number { }

SPU := 400
PIN_SERVO := 3

test := 1

test = ["a", "b", "c"]

type option = "c" | "d"

type optionArr = option[4]

type car = {
  door: number,
  color: string
}


fn add(x: int, y: int): int {

  for {
    if x < 10 { break }
    else { 
      x += 1 
      continue
    }
  }

  return x+y
}
`

const testSimple = `

3
true
a
"test string"


if true then 4 else 65


a := "cars"

call(3, "cas")

[ 4, 5, 6 ]

for {
  3
}
`

console.time("tok")
const toks = tokenizer(testSimple);
console.timeEnd("tok")

console.time("parse")
const result = parse(testSimple);
console.timeEnd("parse")


console.log(toks);

console.log(result[1].map(line => line + ";\n").join("")); // 4

</script>