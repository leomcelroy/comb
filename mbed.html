<script type="module">
import { comb, makeLexer } from "./comb.js";

const skip = [ "whitespace", "comment" ];


const operatorList = [
    ['+=','-=','*=','/=','%=','>>=','<<=','&=','|=','^=','='],
    ["||"],
    ["&&"],
    ["|"],
    ["^"],
    ["&"],
    ['==','!='],
    ['<','>','<=','>='],
    ['<<','>>'],
    ['+','-'],
    ['*','%','/'],
  ];

let operatorUpcast = ['f32','u32','i32','u16','i16','u8','i8'];
let arithOperators = [
  '+=','-=','*=','/=','%=','=',
  '+','-',
  '*','%','/',
]
let CTypeMap = {
  'f32':'float',
  'u32':'uint32_t',
  'i32':'int32_t',
  'u16':'uint16_t',
  'i16':'int16_t',
  'u8':'uint8_t',
  'i8':'int8_t'
}

const operators = operatorList.reduce( (acc, cur, i) => {
    cur.forEach(op => acc[op] = i);

    return acc;
  }, {});

const rules = {
  binaryOperator: operatorList.flat(),
  unaryOperator: ['+', '-', '!'],
  number: /\d+(\.\d+)?/,
  string: /"([^"]*)"/,
  boolean: ["true", "false"],
  id: /[a-zA-Z_][a-zA-Z0-9_]*/,
  whitespace: /[ \t\r\n]*/,
  comment: /\/\/.*\n/
}


const parse = comb`
  lexer ${ { rules, skip } }

  include = "include" 'string'

  declare = 'id' ":" typeDefinition? "=" expression
  declare -> ${
    ([id,_,typeDefinition,__,expression])=>{
      return {tag:"declare",key:id.value,type:typeDefinition,value:[expression]}
    }
  }

  type = "type" 'id' "=" typeDefinition

  typeDefinition = typeTerm ("|" typeTerm)*
  typeTerm = arrayType | objectType | ('id' "." 'id') | 'id' | 'string'

  arrayType = 'id' "[" 'number' "]"

  objectType = "{" (fieldDefinition ",")* fieldDefinition? "}"
  fieldDefinition = 'id' ":" typeDefinition

  function = "fn" 'id' "(" parameters ")" (":" typeDefinition)? block
  parameters = (parameter ",")* parameter?
  parameter = 'id' ":" typeDefinition

  statement = type 
    | function 
    | forStatement 
    | expression
    | "continue"
    | "break"
    | ("return" expression?)
  
  ifStatement = "if" expression block ("else" (block | ifStatement))?
  ifStatement -> ${x => {
    const [_, cond, block1, elseStatement] = x;
    if (elseStatement === null) {
      return { tag: "if", value: [ cond, block1 ]}
    } else {
      const [_, block2] = elseStatement;
      return { tag: "if", value: [ cond, block1, block2 ]}
    }
  }}


  forStatement = "for" ('id' "in" expression)? block

  call = 'id' "(" (expression ",")* expression? ")"
  call -> ${x => {
    const [callee, _, args, lastArg, __] = x;
    return { 
      type: "call", 
      callee, 
      args: lastArg ? [...args.map(x => x[0]), lastArg] : args,
    }
  }}

  literal = 'number' | 'string' | 'boolean' | 'id'
  literal -> ${
    (x) => {
      if (x.type == 'number') {
        return {
          tag: 'atom',
          type: x.value.includes('.') ? 'f32' : 'i32',
          value: [ Number(x.value) ]
        };
      } else {
        
        let a= {
          tag:'atom',
          type: x.type=='id' ? null : x.type,
          value:[x.value]
        };

        if (x.type == 'id') {
          a.key = x.value;
        }

        return a;
      }
    }
  }




  array = "[" (expression ",")* expression? "]"

  block = "{" statement* "}"
  block -> ${
    (x)=>{
      return {
        tag:'block',
        value:x[1],
      }
    }
  }

  paren = "(" expression ")"
  paren -> ${x => x[1]}

  partialExp = declare 
    | block
    | call 
    | ifStatement
    | literal
    | array
    | 'unaryOperator' expression
    | paren

  expression = partialExp ( 'binaryOperator' partialExp )*
  expression -> ${(x) => {
    const [partial, binaryOps] = x;
    if (binaryOps) {
      return shuntingYard([partial, ...binaryOps.flat(1)], operators)
    } else {
      return partial
    }
  }}

  include* statement*
`

  // ternary = "if" expression "then" expression "else" expression
  // ternary -> ${x => {
  //   const [_, cond, __, exp1, ___, exp2 ] = x;

  //   return { tag: "ternary", value: [ cond, exp1, exp2 ] }
  // }}

const tokenizer = makeLexer({ rules, skip });

function inferTypes(tree,context=[[]]){

  if (!Array.isArray(tree)){
    return inferOne(tree);
  }

  for (let i = 0; i < tree.length; i++){
    inferOne(tree[i]);
  }

  function search(x){
    for (let i = 0; i < context.length; i++){
      if (context[i][x]) return context[i][x];
    }
    throw 'undefined variable '+x;
  }

  function upcastable(op,a,b){
    if (!arithOperators.includes(op)){
      return undefined;
    }
    let idx = Math.min(operatorUpcast.indexOf(a),operatorUpcast.indexOf(b));
    return operatorUpcast[idx];
  }

  function infer(x){
    if (x.type) return x.type;
    if (x.tag == "block"){
      inferOne(x);
      return x.type;
    }

    if (x.tag === "declare") {
      return infer(x.value[0]);
    }

    if (x.tag == 'binop'){
      let a = infer(x.value[0]);
      let b = infer(x.value[1]);
      x.value[0].type = a;
      x.value[1].type = b;
      if (a === b){
        x.type = a;
        return a;
      }else{
        if (!(x.type = upcastable(x.op,a,b))){
          throw 'mismatched type '+a+' '+b;
        }
        return x.type;
      }
    } else if (x.tag == 'if') {
      // console.log("------")
      // console.log(x.value[1],x.value[2],x.value[1].type,x.value[2].type);
      // let cond = infer(x.value[0]);
      let trueClause = infer(x.value[1]);
      let falseClause = x.value.length > 2 ? infer(x.value[2]) : trueClause;
      // console.log(x.value[1],x.value[2],x.value[1].type,x.value[2].type);

      if (trueClause === falseClause) {
        x.type = trueClause;
        return trueClause;
      } else {
        // if (!(x.type = upcastable(,trueClause,falseClause))){
        throw 'mismatched type '+trueClause+' '+falseClause;
        // }
      }
    } else if (x.tag == 'atom'){
      if (x.type == null && x.key){
        return (x.type = search(x.key));
      }
    }
  }

  function inferOne(q){


    if (q.tag == 'block'){
      context.unshift([]);
      for (let j = 0; j < q.value.length; j++){
        inferTypes(q.value[j],context);
      }
      context.shift();
      q.type = infer(q.value.at(-1));
    } else if (!q.type) {
      q.type = infer(q);
      if (q.tag == 'declare') {
        context[0][q.key] = q.type;
      }
    } else if (q.tag != 'atom'){
      for (let j = 0; j < q.value.length; j++){
        inferTypes(q.value[j],context);
      }
    }
  }
}

function generateC(tree,inlineBlocks=false){
  
  let o = ``;
  if (Array.isArray(tree)){
    for (let i = 0; i < tree.length; i++){
      o += generateC(tree[i],inlineBlocks);
      if (!inlineBlocks){
        o += ';';
        if (i != tree.length-1){
          o += '\n';
        }
      }
    }
  }else if (tree.tag == 'atom'){
    o += tree.value[0];
  }else if (tree.tag == 'declare'){
    o += `${CTypeMap[tree.type]??tree.type} ${tree.key} = ${generateC(tree.value[0],true)}`;
  }else if (tree.tag == 'binop'){
    o += `((${generateC(tree.value[0])}) ${tree.op} (${generateC(tree.value[1],tree.op=='=')}))`;
  }else if (tree.tag == 'if'){
    if (inlineBlocks){
      o += `(${generateC(tree.value[0])}) ? (${generateC(tree.value[1],true)}) : (${generateC(tree.value[2],true)})`;
    }else if (tree.value[2]){
      o += `if (${generateC(tree.value[0],true)}) {${generateC(tree.value[1])}} else {${generateC(tree.value[2])}}`;
    }else{
      o += `if (${generateC(tree.value[0],true)}) {${generateC(tree.value[1])}}`;
    }
  }else if (tree.tag == 'block'){
    let oo = generateC(tree.value,inlineBlocks)
    if (inlineBlocks){
      o += oo;
    }else{
      oo = oo.split('\n').map(x=>'  '+x).join('\n');
      o += '\n'+oo+'\n';
    }
  }
  return o;
}

// const test = `
// x := 3
// y := 4
// s := "hello"
// t := ""

// if true {
//   4
// } else {
//   5
// }

// if x+y == 6 {
//   x += 1
// } else if false {
//   x -= 1
// } else {
//   x -= 1
// }

// tern := if true {
//   "orange"
// } else {
//   "red"
// }

// 4+9

// {
//   z := x + y
//   t = "world "+s
// }
// `

const test = `
x := 0.1
y := 2
z := x + y
z = 3
a := if 1+2 {3} else {4}
if true {
  4
} else if false {
  5
} else {
  6
}

{
  z = 4
}

`;

console.time("tok")
const toks = tokenizer(test);
console.timeEnd("tok")

console.time("parse")
const result = parse(test);
console.timeEnd("parse")

inferTypes(result[1]);

console.log(toks);
console.log(result[1]);


let c = generateC(result[1]);
console.log(c);

function shuntingYard(operations, precedenceMap) {
  const outputQueue = [];
  const operatorStack = [];

  for (const item of operations) {
    if (item.type === "binaryOperator") {
      const op = item.value;
      while (
        operatorStack.length > 0 &&
        precedenceMap[op] <= precedenceMap[operatorStack.at(-1).value]
      ) {
        outputQueue.push(operatorStack.pop());
      }
      operatorStack.push(item);
    } else {
      outputQueue.push(item);
    }
  }

  while (operatorStack.length > 0) {
    outputQueue.push(operatorStack.pop());
  }

  const operandStack = [];

  for (const item of outputQueue) {
    if (item.type === "binaryOperator") {
      const right = operandStack.pop();
      const left = operandStack.pop();

      operandStack.push({ tag:'binop', op:item.value, value:[ left, right ] });
      // operandStack.push({ operator: item.value, left, right });
    } else {
      operandStack.push(item);
    }
  }

  return operandStack[0];
}



</script>