<script type="module">
import { comb, makeLexer } from "./comb.js";

const skip = [ "whitespace", "comment" ];


const operatorList = [
    ['+=','-=','*=','/=','%=','>>=','<<=','&=','|=','^=','='],
    ["||"],
    ["&&"],
    ["|"],
    ["^"],
    ["&"],
    ['==','!='],
    ['<','>','<=','>='],
    ['<<','>>'],
    ['+','-'],
    ['*','%','/'],
  ];

const operators = operatorList.reduce( (acc, cur, i) => {
    cur.forEach(op => acc[op] = i);

    return acc;
  }, {});

const rules = {
  // literals: [ 
  //   "[", 
  //   "]", 
  //   "{", 
  //   "}", 
  //   "(", 
  //   ")", 
  //   ",", 
  //   "|", 
  //   "then", 
  //   ".", 
  //   "if", 
  //   "else",
  //   "for",
  //   "in",
  //   "fn",
  //   "break",
  //   "continue",
  //   "return",
  //   "type",
  //   "include",
  //   ":",
  // ],
  binaryOperator: operatorList.flat(),
  unaryOperator: ['+', '-', '!'],
  number: /\d+(\.\d+)?/,
  string: /"([^"]*)"/,
  boolean: ["true", "false"],
  id: /[a-zA-Z_][a-zA-Z0-9_]*/,
  whitespace: /[ \t\r\n]*/,
  comment: /\/\/.*\n/
}


const parse = comb`
  lexer ${ { rules, skip } }

  include = "include" 'string'

  declare = 'id' ":" typeDefinition? "=" expression
  declare -> ${
    ([id,_,typeDefinition,__,expression])=>{
      return {tag:"declare",key:id.value,type:typeDefinition,value:[expression]}
    }
  }

  type = "type" 'id' "=" typeDefinition

  typeDefinition = typeTerm ("|" typeTerm)*
  typeTerm = arrayType | objectType | ('id' "." 'id') | 'id' | 'string'

  arrayType = 'id' "[" 'number' "]"

  objectType = "{" (fieldDefinition ",")* fieldDefinition? "}"
  fieldDefinition = 'id' ":" typeDefinition

  function = "fn" 'id' "(" parameters ")" (":" typeDefinition)? block
  parameters = (parameter ",")* parameter?
  parameter = 'id' ":" typeDefinition

  statement = type 
    | function 
    | forStatement
    | ifStatement 
    | expression
    | "continue"
    | "break"
    | ("return" expression?)
  
  ifStatement = "if" expression block ( "else" "if" expression block )* ( "else" block)?

  forStatement = "for" ('id' "in" expression)? block

  call = 'id' "(" (expression ",")* expression? ")"

  literal = 'number' | 'string' | 'boolean' | 'id'
  literal -> ${
    (x) => {
      if (x.type == 'number') {
        return {
          tag: 'atom',
          type: 'number',
          value: [ Number(x.value) ]
        };
      } else {
        
        let a= {
          tag:'atom',
          type: x.type=='id' ? null : x.type,value:[x.value]
        };

        if (x.type == 'id') {
          a.key = x.value;
        }

        return a;
      }
    }
  }

  ternary = "if" expression "then" expression "else" expression


  array = "[" (expression ",")* expression? "]"

  block = "{" statement* "}"
  block -> ${
    (x)=>{
      return {
        tag:'block',
        value:x[1],
      }
    }
  }

  paren = "(" expression ")"
  paren -> ${x => x[1]}

  partialExp = declare 
    | block
    | call 
    | literal
    | ternary
    | array
    | 'unaryOperator' expression
    | paren

  expression = partialExp ( 'binaryOperator' partialExp )*
  expression -> ${(x) => {
    const [partial, binaryOps] = x;
    if (binaryOps) {
      return shuntingYard([partial, ...binaryOps.flat(1)], operators)
    } else {
      return partial
    }
  }}

  include* statement*
`

const tokenizer = makeLexer({ rules, skip });

function inferTypes(tree,context=[[]]){

  if (!Array.isArray(tree)){
    return inferOne(tree);
  }

  for (let i = 0; i < tree.length; i++){
    inferOne(tree[i]);
  }

  function search(x){
    for (let i = 0; i < context.length; i++){
      if (context[i][x]) return context[i][x];
    }
    throw 'undefined variable '+x;
  }

  function infer(x){
    if (x.type) return x.type;

    if (x.tag === "declare") {
      return infer(x.value[0]);
    }

    if (x.tag == 'binop'){
      let a = infer(x.value[0]);
      let b = infer(x.value[1]);
      x.value[0].type = a;
      x.value[1].type = b;
      if (a === b){
        x.type = a;
        return a;
      }else{
        throw 'mismatched type '+a+' '+b;
      }
    } else if (x.tag == 'atom'){
      if (x.type == null && x.key){
        return (x.type = search(x.key));
      }
    }
  }

  function inferOne(q){
    if (!q.type) {
      q.type = infer(q);
      if (q.tag == 'declare') {
        context[0][q.key] = q.type;
      }
    }

    if (q.tag == 'block'){
      context.unshift([]);
      for (let j = 0; j < q.value.length; j++){
        inferTypes(q.value[j],context);
      }
      context.shift();
    } else if (q.tag != 'atom'){
      for (let j = 0; j < q.value.length; j++){
        inferTypes(q.value[j],context);
      }
    }
  }
}

const test = `
z := "car"
z = "car" + z
`

console.time("tok")
const toks = tokenizer(test);
console.timeEnd("tok")

console.time("parse")
const result = parse(test);
console.timeEnd("parse")

inferTypes(result[1]);

console.log(toks);
console.log(result[1]);

function shuntingYard(operations, precedenceMap) {
  const outputQueue = [];
  const operatorStack = [];

  for (const item of operations) {
    if (item.type === "binaryOperator") {
      const op = item.value;
      while (
        operatorStack.length > 0 &&
        precedenceMap[op] <= precedenceMap[operatorStack.at(-1).value]
      ) {
        outputQueue.push(operatorStack.pop());
      }
      operatorStack.push(item);
    } else {
      outputQueue.push(item);
    }
  }

  while (operatorStack.length > 0) {
    outputQueue.push(operatorStack.pop());
  }

  const operandStack = [];

  for (const item of outputQueue) {
    if (item.type === "binaryOperator") {
      const right = operandStack.pop();
      const left = operandStack.pop();

      operandStack.push({ tag:'binop', op:item.value, value:[ left, right ] });
      // operandStack.push({ operator: item.value, left, right });
    } else {
      operandStack.push(item);
    }
  }

  return operandStack[0];
}



</script>