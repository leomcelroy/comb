<script type="module">
import { comb, makeLexer } from "./comb.js";

const skip = [ "whitespace", "comment" ];

const rules = {
  "[": "[",
  "]": "]",
  "{": "{",
  "}": "}",
  "(": "(",
  ")": ")",
  ",": ",",
  "|": "|",
  "then": "then",
  ".": ".",
  "if": "if",
  // "elif": "elif",
  "else": "else",
  "for": "for",
  "in": "in",
  "fn": "fn",
  // "do": "do",
  "enum": "enum",
  "const": "const",
  "return": "return",
  "type": "type",
  "import": "import",
  ";": ";",
  "=": "=",
  ":": ":",
  binaryOperator: ['*', '/', '==', '!=', '+', '-', '<', '<=', '>', '>=', '<<', '>>', "|", "&", "%", "+=", "-=", "&&", "||"],
  unaryOperator: ['+', '-', '!'],
  number: /\d+(\.\d+)?/,
  string: /"([^"]*)"/,
  boolean: ["true", "false"],
  // primitive: [
  //   "string", 
  //   "boolean", 
  //   "int8",
  //   "int16",
  //   "int32",
  //   "int64",  
  //   "uint8",
  //   "uint16",
  //   "uint32",
  //   "uint64",
  //   "float8",
  //   "float16",
  //   "float32",
  //   "float64",
  //   "byte",
  //   "char",
  //   "void",
  // ],
  id: /[a-zA-Z_][a-zA-Z0-9_]*/,
  whitespace: /[ \t\r\n]*/,
  comment: /\/\/.*\n/
}


const parse = comb`
  lexer ${ { rules, skip } }

  import = 'import' 'string'

  declare = 'const'? 'id' ':' typeDefinition? '=' expression
  assign = 'id' '=' expression

  enum = 'enum' 'id' '=' '{' ('id' ',')*  'id'? '}'

  type = 'type' 'id' '=' typeDefinition

  typeDefinition = typeTerm ('|' typeTerm)*
  typeTerm = arrayType | objectType | ('id' '.' 'id') | 'id' | 'string'

  arrayType = 'id' '[' 'number' ']'

  objectType = '{' (fieldDefinition ',')* fieldDefinition? '}'
  fieldDefinition = 'id' ':' typeDefinition

  function = 'fn' 'id' '(' parameters ')' ':' typeDefinition '{' (statement | returnStatement)* '}'
  parameters = (parameter ',')* parameter?
  parameter = 'id' ':' typeDefinition

  statement = type 
    | enum 
    | function 
    | forStatement
    | ifStatement 
    | expression

  returnStatement = 'return' expression
  
  ifStatement = 'if' expression '{' statement* '}' ( 'else' 'if' expression '{' statement* '}')* ( 'else' '{' statement* '}')?

  forStatement = 'for' 'id' 'in' expression '{' statement* '}'
  // forStatement = 'for' (iteratorCount | inLoop) '{' statement* '}'
  // iteratorCount = expression? ';' expression? ';' expression?
  // inLoop = 'id' 'in' expression

  call = 'id' '(' (expression ',')* expression? ')'

  literal = 'number' | 'string' | 'boolean' | 'id'

  ternary = 'if' expression 'then' expression 'else' expression

  array = '[' (expression ',')* expression? ']'

  partialExp = assign 
    | declare 
    | call 
    | literal
    | ternary
    | array
    | 'unaryOperator' expression

  biOp = partialExp 'binaryOperator' expression

  expression = biOp | ('(' expression ')') | partialExp

  import* statement*
`

const example = String.raw`
import "Servo.h"

const SPU = 400
const PIN_SERVO = 3

test = 1

test = ["a", "b", "c"]

enum color = { RED, BLUE, GREEN }

type option = "c" | "d"

type optionArr = option[4]

type car = {
  door: number,
  color: string
}

fn add(x: int, y: int): int {
  return x+y
}
`

const tokenizer = makeLexer({ rules, skip });

const test = String.raw`
import "servo.h"

const SPU: int = 400
const PIN_SERVO = 3

test = 1

enum color = { RED, GREEN, BLUE }

type arr = orange[3]

type house = {
  door: "number",
  color: color.RED | orange
}

if x < 89 {

} else {
  65
}

if x < 89 {

} else if true {
  65
}

if 78 then 67 else 56

for x in 32 {

}

5 - 9 + 7

for i = 0; i < 10; i = i+1 {

}

fn add(x: number, y: number): number { }

const SPU = 400
const PIN_SERVO = 3

test = 1

test = ["a", "b", "c"]

enum color = { RED, BLUE, GREEN }

type option = "c" | "d"

type optionArr = option[4]

type car = {
  door: number,
  color: string
}


fn add(x: int, y: int): int {
  return x+y
}
`

console.time("tok")
const toks = tokenizer(test);
console.timeEnd("tok")

console.time("parse")
const result = parse(test);
console.timeEnd("parse")


console.log(toks);

console.log(result); // 4

</script>